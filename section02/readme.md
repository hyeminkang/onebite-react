truthy falsy
ㄴ blooean 타입이 아니더라도, 참과 거짓으로 판단하는 경우도 있음
ㄴ truthy : 참은 아니지만 조건문 내에서 참으로 평가되는 참값은 값
ㄴ falsy : 거짓은 아니지만 조건문 내에서 거짓으로 평가되는 거짓같은 값



단락평가
ㄴ && || 논리연산식에서 첫번째 피연산자의 값만으로도 연산의 결과를 알 수 있다면, 두번째 피 연산자에 아예 접근하지 않는 자바스크립트의 특징
ㄴ && 연산자는 둘다 참이여야함으로, 한쪽만 false여도 무조건 false, 그럼 두번째에 접근할 필요가없음 첫번째가 false 였으니까~ 
ㄴ || 연산자도 둘중하나만 true 여도 무조건 true니까~ 
ㄴ 이런걸 단락평가라고 부름 
ㄴ 앞으로는 조건문을 이용하지않고도 어떤 상황에서 함수를 호출하지않도록 방지해주거나 어떠한 값들을 굳이 계산하지않도록 제한하는 등의 다양한 기능을 개발할수 있기떄문에 사용함!



구조 분해할당
ㄴ 배열이나 객체에 저장된 여러개의 값들을 말 그대로 분해해서 다른 변수에 할당하는 방법



spread 연산자, Rest 매개변수
ㄴ spread 연산자 : 객체나 배열에 저장된 여러개의 값을 개별로 흩뿌려주는 역할



원시타입, 객체타입
ㄴ 원시타입과 객체타입으로 나누는 이유는, 값이 저장되거나 복사되는 과정이 서로 다르기 떄문임!
ㄴ 원시타입 : 값 자체로써 변수에 저장되고 복사됨
ㄴ 객체타입 : 참조값을 통해 변수에 저장되고 복사됨 

<< 원시타입 == 불변형 >> 
let p1 = 1;
let p2 = p1;
1의 값이 먼저 메모리에 들어가고 P1이 가리킴, 
1이 들어오고 p2가 가리킴,
2로 변경이 된다면 2가 먼저 메모리에 자리잡고 p2가 가리킴
이때 중요한 부분은 변수의 값이 1> 2로 변경되어도 메모리 값은 수정되지 않아요. 대신 변경해야되는 값을 새로운 값에 저장하여 가리키는 방향만 달라짐
변경이 되어도 메모리에 저장한 원본 데이터가 수정되지는 않기떄문에 원시타입의 값들을 불변값이라고 부름

<< 객체타입 == 가변값 >>
let o1 = {name : "이정환"};
원시타입처럼 메모리에 {name : "이정환"} 이 저장되고 o1이 가리킬 것 같지만, 이렇게 동작하지않음
대신에, 메모리 어딘가에  {name : "이정환"}를 저장해둔 다음에 o1에는 객체값이 저장된 메모리공간을 가리키는 주소값인 참조값을 저장
ㄴ 이유는 객체는 막 여러개를 저장했다가~ 개수가 동적으로 늘었다가 줄어들기도하고 그러니까 별도의 메모리공간에 보관 함
그이후에 
let o2 = o1 ; // 얕은 방식
o2에 o1값을 복사해 초기화를 시켜주면, 이 두변수가 모두 같은 참조값을 가리키게 됨!! 
이때 만약에 o2객체의 name property 값을 홍길동을 변경해준다면
o2.name= "홍길동" 
이러면 원시타입은 메모리에 자리잡고 다시 가리키게 하게지만, 
객체타입은 그렇게 하지않고 그냥 수정해버림 그래서 같은 참조값을 가리키고 있었으므로, o1값도 바뀜 
메모리 자체르 바꿔버리므로 가변값이라고 부름

(객체타입 주의사항)
1. 의도치 않게 값이 수정될 수 있다.
ㄴ side effect : 의도하지않았는데, 하나의 변화가 또 다른 변수의 변화를 가져오는 이런 것들 
그러므로 let o2 = o1; 이렇게 복사해오는게 아니라 새로운 객체를 생성하고, 그 내부에 o1처럼 스프레드 연산자를 이용해서 가져와야함
(새로운 객체를 생성하면서, 내부 프로퍼티만 복사해오는 방식)
ㄴ let o2 = {...o1} // 깊은 복사
이렇게 되면 o2변수는 o1과 다른 아예 새로운 변수로 저장되기떄문에 새로운 메모리 생성되고 새로운 참조값이 생성됨
2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다
let o1 = {name : "이정환"};
let o2 = o1; 
let o3 = {...o1}; 
console.log(o1 === o2); // 당연히 true 왜냐면 얘넨 같은 구조의 객체를 보관하고있을뿐만 아니라, 참조값까지 같음 
console.log(o1 === o3);  // 얘넨 당연히다름, 같은 객체는 맞지! 똑같은게 들어갔고, 스프레드로 불러왔잖어, 결과는 false 임 ! 
// 객체간의 비교연산은 참조값을 기준으로 이루어지기때문임 참조값이 달라서 얘넨 false임
참조값이 아닌 프로퍼티를 기준으로 비교하고 싶다면
JSON.stringify() 자바스크립트 내장함수로 객체를 문자열로 형 변환하는 함수를 활용해서 비교해야함 (그럼 프로퍼티를 기준으로 비교함)
얕은비교 
o1 === o2
깊은비교
JSON.stringify(o1) === JSON.stringify(o2)

3. 배열과 함수도 사실 객체다!
자바스크립트의 배열과 함수는 특수한 객체들이기 떄문에 배열과 함수 또한 
일반 객체에 존재하는 프로퍼티와 메서드를 다 가지고있음! 그래서 추가적인
프로퍼티와 메서드를 가질수 있다! 



반복문으로 배열과 객체순회하기
ㄴ 순회란 : 배열, 객체에 저장된 여러개의 값에 순서대로 하나씩 접근하는것
배열순회
let numbers = [1,2,3];
객체순회
let person = {
    name : "이정환",
    age : 27,
    hobby : "테니스",
}



배열메서드
ㄴ 배열 메서드를 수정 추가 삭제 등을 배워볼예정! 
ㄴ 배열을 순회하고 탐색하는 그런 메서드들!
ㄴ 배열을 변형해서 새로운 배열로 반환하거나 문자열로 묶어서 반환하는 메서드들



Date객체와 날짜
