truthy falsy
ㄴ blooean 타입이 아니더라도, 참과 거짓으로 판단하는 경우도 있음
ㄴ truthy : 참은 아니지만 조건문 내에서 참으로 평가되는 참값은 값
ㄴ falsy : 거짓은 아니지만 조건문 내에서 거짓으로 평가되는 거짓같은 값



단락평가
ㄴ && || 논리연산식에서 첫번째 피연산자의 값만으로도 연산의 결과를 알 수 있다면, 두번째 피 연산자에 아예 접근하지 않는 자바스크립트의 특징
ㄴ && 연산자는 둘다 참이여야함으로, 한쪽만 false여도 무조건 false, 그럼 두번째에 접근할 필요가없음 첫번째가 false 였으니까~ 
ㄴ || 연산자도 둘중하나만 true 여도 무조건 true니까~ 
ㄴ 이런걸 단락평가라고 부름 
ㄴ 앞으로는 조건문을 이용하지않고도 어떤 상황에서 함수를 호출하지않도록 방지해주거나 어떠한 값들을 굳이 계산하지않도록 제한하는 등의 다양한 기능을 개발할수 있기떄문에 사용함!



구조 분해할당
ㄴ 배열이나 객체에 저장된 여러개의 값들을 말 그대로 분해해서 다른 변수에 할당하는 방법



spread 연산자, Rest 매개변수
ㄴ spread 연산자 : 객체나 배열에 저장된 여러개의 값을 개별로 흩뿌려주는 역할



원시타입, 객체타입
ㄴ 원시타입과 객체타입으로 나누는 이유는, 값이 저장되거나 복사되는 과정이 서로 다르기 떄문임!
ㄴ 원시타입 : 값 자체로써 변수에 저장되고 복사됨
ㄴ 객체타입 : 참조값을 통해 변수에 저장되고 복사됨 

<< 원시타입 == 불변형 >> 
let p1 = 1;
let p2 = p1;
1의 값이 먼저 메모리에 들어가고 P1이 가리킴, 
1이 들어오고 p2가 가리킴,
2로 변경이 된다면 2가 먼저 메모리에 자리잡고 p2가 가리킴
이때 중요한 부분은 변수의 값이 1> 2로 변경되어도 메모리 값은 수정되지 않아요. 대신 변경해야되는 값을 새로운 값에 저장하여 가리키는 방향만 달라짐
변경이 되어도 메모리에 저장한 원본 데이터가 수정되지는 않기떄문에 원시타입의 값들을 불변값이라고 부름

<< 객체타입 == 가변값 >>
let o1 = {name : "이정환"};
원시타입처럼 메모리에 {name : "이정환"} 이 저장되고 o1이 가리킬 것 같지만, 이렇게 동작하지않음
대신에, 메모리 어딘가에  {name : "이정환"}를 저장해둔 다음에 o1에는 객체값이 저장된 메모리공간을 가리키는 주소값인 참조값을 저장
ㄴ 이유는 객체는 막 여러개를 저장했다가~ 개수가 동적으로 늘었다가 줄어들기도하고 그러니까 별도의 메모리공간에 보관 함
그이후에 
let o2 = o1 ; // 얕은 방식
o2에 o1값을 복사해 초기화를 시켜주면, 이 두변수가 모두 같은 참조값을 가리키게 됨!! 
이때 만약에 o2객체의 name property 값을 홍길동을 변경해준다면
o2.name= "홍길동" 
이러면 원시타입은 메모리에 자리잡고 다시 가리키게 하게지만, 
객체타입은 그렇게 하지않고 그냥 수정해버림 그래서 같은 참조값을 가리키고 있었으므로, o1값도 바뀜 
메모리 자체르 바꿔버리므로 가변값이라고 부름

(객체타입 주의사항)
1. 의도치 않게 값이 수정될 수 있다.
ㄴ side effect : 의도하지않았는데, 하나의 변화가 또 다른 변수의 변화를 가져오는 이런 것들 
그러므로 let o2 = o1; 이렇게 복사해오는게 아니라 새로운 객체를 생성하고, 그 내부에 o1처럼 스프레드 연산자를 이용해서 가져와야함
(새로운 객체를 생성하면서, 내부 프로퍼티만 복사해오는 방식)
ㄴ let o2 = {...o1} // 깊은 복사
이렇게 되면 o2변수는 o1과 다른 아예 새로운 변수로 저장되기떄문에 새로운 메모리 생성되고 새로운 참조값이 생성됨
2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다
let o1 = {name : "이정환"};
let o2 = o1; 
let o3 = {...o1}; 
console.log(o1 === o2); // 당연히 true 왜냐면 얘넨 같은 구조의 객체를 보관하고있을뿐만 아니라, 참조값까지 같음 
console.log(o1 === o3);  // 얘넨 당연히다름, 같은 객체는 맞지! 똑같은게 들어갔고, 스프레드로 불러왔잖어, 결과는 false 임 ! 
// 객체간의 비교연산은 참조값을 기준으로 이루어지기때문임 참조값이 달라서 얘넨 false임
참조값이 아닌 프로퍼티를 기준으로 비교하고 싶다면
JSON.stringify() 자바스크립트 내장함수로 객체를 문자열로 형 변환하는 함수를 활용해서 비교해야함 (그럼 프로퍼티를 기준으로 비교함)
얕은비교 
o1 === o2
깊은비교
JSON.stringify(o1) === JSON.stringify(o2)

3. 배열과 함수도 사실 객체다!
자바스크립트의 배열과 함수는 특수한 객체들이기 떄문에 배열과 함수 또한 
일반 객체에 존재하는 프로퍼티와 메서드를 다 가지고있음! 그래서 추가적인
프로퍼티와 메서드를 가질수 있다! 



반복문으로 배열과 객체순회하기
ㄴ 순회란 : 배열, 객체에 저장된 여러개의 값에 순서대로 하나씩 접근하는것
배열순회
let numbers = [1,2,3];
객체순회
let person = {
    name : "이정환",
    age : 27,
    hobby : "테니스",
}



배열메서드
ㄴ 배열 메서드를 수정 추가 삭제 등을 배워볼예정! 
ㄴ 배열을 순회하고 탐색하는 그런 메서드들!
ㄴ 배열을 변형해서 새로운 배열로 반환하거나 문자열로 묶어서 반환하는 메서드들



Date객체와 날짜



동기 vs 비동기
ㄴ 동기란 : 여러개의 작업이 있을 경우에 순서대로 한번에 하나씩만 처리하는 것
TASK A 실행 > TASK A 종료 > TASK B 실행 > TASK B 종료 하며 작업을 순서대로 완료하는 이러한 흐름으로 표현가능
작업을 직접 실행하고, 또 처리해주는 역할을 하는 친구의 이름은 쓰레드!
Javascript는 "동기"적으로 코드를 실행한다!

쉽게 말해서 위에서부터 아래로 실행됨! 실행 흐름을 파악하기 쉽고 용이하다는 장점이 있음!
그러나 단점이 있음
만약에 taskA 0.1초, taskB 0.3초, taskC 0.2초로 짧으면 상관없는데 예를들어 taskB가 10초 이러면 다음작업인 taskC를 실행하지 않기떄문에 전체 프로그램의 성능익 악화됨!!!

다른 언어는 멀티쓰레드를 이용하는데,, Javascript는 쓰레드가 1개뿐임ㅠㅠ 
그래서 자바스크립트에서는 비동기라는 방식을 활용하여 해결함

ㄴ 비동기란 : 동기적이지 않다, 작업을 순서대로 처리하지 않음!
앞선 작업이 종료되지않아도 다른작업을 동시에 진행시키는게 가능함
각각의 작업들이 종료되었을때 해당작업의 결과값을 이용해서 또다른 동작을 수행시켜줘야된다면 자바스크립트에세는 각각의 작업에 콜백함수를 붙여 처리하는것이 가능

 webAPIs 
 ㄴ 웹 브라우저가 직접 관리하는 별도의 영역
 ㄴ 이 영역이 자바스크립트의 비동기 작업들이 실행되는 영역
 ㄴ 비동기 함수를 만나게 되면 이 비동기 작업을 부탁함, 그러면서 이후 실행할 콜백함수까지 전달



promise
ㄴ 효율적으로 처리할수 있도록 도와주는 자바스크립트의 내장객체
ㄴ like date~ 
ㄴ 비동기작업을 실행하고 그 결과를 처리하는 코드를 좀 더 효율적이고 좀 더 편하게 작성할수있도록 도와줌
ㄴ promise 는 setTimeout 함수와 같은 비동기 작업들을 랩핑하는 객체
ㄴ [비동기작업을 실행]시켜주거나, [현재의 상태를 관리]하거나 또는 [비동기 작업의 결과를 저장]해주거나 심지어 [여러개의 작업을 병렬로 동시에 실행]시켜주거나 아니면 [다시 실행]시켜주는 등의 비동기 작업의 처리하는 데 필요한 곳에 거의 모든 기능을 다 제공해주는 그런 객체임 
ㄴ promise 비동기 작업 진행 단계에 따라서 세가지의 상태로 나눔
- [대기 pending] - 아직 작업이 완료되지 않은 상태
- [성공 fulfilled] - 비동기 작업이 성공적으로 마무리 된 상태
- [실패 rejected] - 비동기 작업이 실패한 상태

대기 상태였다가 작업이 성공적으로 완료되어서 성공상태로 바뀌는걸 resolve라고함
대기상태였다가 모종의 이유로 실패해서 실패상태로 바뀌는걸 reject 되었따고 함 

유튜브로 비교해보기
로딩상태 : pending 
영상 로딩이 성공적으로 되어 시청가능한 상태가 되는건 : resolve
시청가능해진 상태 : Fulfilled

로딩실패 : reject
실패상태 : rejected


async & awit
